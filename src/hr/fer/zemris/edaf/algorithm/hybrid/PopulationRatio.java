package hr.fer.zemris.edaf.algorithm.hybrid;

import hr.fer.zemris.edaf.MSGPrinter;
import hr.fer.zemris.edaf.genotype.Individual;
import hr.fer.zemris.edaf.statistics.Statistics;

import java.text.DecimalFormat;
import java.util.Arrays;

/**
 * Estimating the ratio of individuals in the population of both algorithms.
 * 
 * @author Karlo Knezevic, karlo.knezevic@fer.hr
 * 
 */
public class PopulationRatio {

	private int counter;

	private final double params;

	private final String name;

	private double ratio;

	private Individual[] p;

	private final int repetition;

	private double bestInFirstLoop;

	public PopulationRatio(String name, int repetition, double params) {

		if (!name.equals("const") && !name.equals("incremental")
				&& !name.equals("alt") && !name.equals("dynamic")) {
			MSGPrinter.printERROR(System.err, "Not supported ratio computing.",
					true, -1);
		}

		this.name = name;
		this.params = params;
		this.repetition = repetition;
		ratio = 0.5;

	}

	public void computeRatio(Individual[] sample1, Individual[] sample2) {

		if (sample1.length != sample2.length) {
			MSGPrinter.printERROR(System.err,
					"Ratio supports only equals samples sizes.", true, -1);
		}

		p = new Individual[sample1.length];

		Arrays.sort(sample1);
		Arrays.sort(sample2);

		if (counter == 0) {
			bestInFirstLoop = Math.min(sample1[0].getFitness(),
					sample2[0].getFitness());
		}

		if (name.equals("const")) {
			constant(sample1, sample2, params);

		} else if (name.equals("incremental")) {
			final int midPoint = (int) Math
					.ceil((repetition - (0.5 * repetition)) / 0.5);
			incremental(sample1, sample2, midPoint);

		} else if (name.equals("alt")) {
			alternate(sample1, sample2);

		} else if (name.equals("dynamic")) {
			dynamic(sample1, sample2);
		}

		counter++;

	}

	/**
	 * The percentage of individuals generated by each method is constant during
	 * all the generations. For example, 30% of the individuals are generated by
	 * GA crossover and mutation and 70% by the EDA probabilistic graphical
	 * model.
	 * 
	 * @param sample1
	 * @param sample2
	 * @param ratioFixed
	 */
	private void constant(Individual[] sample1, Individual[] sample2,
			double ratioFixed) {
		ratio = ratioFixed;
		final int firstSampleIndividualLength = (int) Math.floor(sample1.length
				* ratio);

		for (int i = 0; i < firstSampleIndividualLength; i++) {
			p[i] = sample1[i].copy();
		}

		for (int i = firstSampleIndividualLength; i < sample2.length; i++) {
			p[i] = sample2[i].copy();
		}
	}

	/**
	 * The partition ratio for one of the mechanism increases from one
	 * generation to the other. There are two incremental Participation
	 * Functions, GA Incremental Function and EDA Incremental Function.
	 * 
	 * @param sample1
	 * @param sample2
	 * @param midPoint
	 */
	private void incremental(Individual[] sample1, Individual[] sample2,
			int midPoint) {
		ratio = counter / (midPoint + counter);
		counter++;

		final int firstSampleIndividualLength = (int) Math.floor(sample1.length
				* ratio);

		for (int i = 0; i < firstSampleIndividualLength; i++) {
			p[i] = sample1[i].copy();
		}

		for (int i = firstSampleIndividualLength; i < p.length; i++) {
			p[i] = sample2[i].copy();
		}
	}

	/**
	 * On each generation it alternates either GA or EDA generation method. If
	 * the generation is an even number GA mechanism generates all offspring
	 * individuals, if it is an odd number is the EDA method.
	 * 
	 * @param sample1
	 * @param sample2
	 */
	private void alternate(Individual[] sample1, Individual[] sample2) {

		if ((counter % 2) == 0) {
			for (int i = 0; i < p.length; i++) {
				p[i] = sample1[i].copy();
			}
		} else {
			for (int i = 0; i < p.length; i++) {
				p[i] = sample2[i].copy();
			}
		}
	}

	/**
	 * The idea of this method is to have a mechanism that increases the
	 * participation ratio for the method that happens to generate better
	 * individuals. This function is evaluated each generation considering the
	 * possibility to change the participation criterion
	 * 
	 * @param sample1
	 * @param sample2
	 */
	private void dynamic(Individual[] sample1, Individual[] sample2) {

		if (counter == 0) {
			constant(sample1, sample2, ratio);
			return;
		}

		final double first25Perc = 0.10;

		final double avgS1 = Statistics.getAvgValue(sample1, first25Perc);
		final double avgS2 = Statistics.getAvgValue(sample2, first25Perc);

		double diff = (Math.max(avgS1, avgS2) - bestInFirstLoop)
				/ (Math.min(avgS1, avgS2) - bestInFirstLoop);

		diff = diff > 1 ? 1.0 / diff : diff;

		if (avgS1 > avgS2) {
			ratio = ratio - (ratio * ((1 - diff) / 2));
		}

		if (avgS1 < avgS2) {
			ratio = ratio + ((1 - ratio) * ((1 - diff) / 2));
		}

		constant(sample1, sample2, ratio);

	}

	public Individual[] getUnitedPopulation() {
		return p;
	}

	public double getRatio() {
		return ratio;
	}

	public String getRatio(String format) {
		final DecimalFormat df = new DecimalFormat(format);
		return df.format(ratio).replaceAll(",", ".");
	}
}