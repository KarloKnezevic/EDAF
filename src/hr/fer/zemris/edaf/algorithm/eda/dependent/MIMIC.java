package hr.fer.zemris.edaf.algorithm.eda.dependent;

import hr.fer.zemris.edaf.algorithm.Algorithm;
import hr.fer.zemris.edaf.genotype.Genotype;
import hr.fer.zemris.edaf.genotype.Individual;
import hr.fer.zemris.edaf.selection.Selection;
import hr.fer.zemris.edaf.workenvironment.Evaluation;

import java.util.Arrays;
import java.util.Random;

/**
 * The Mutual Information Maximization for Input Clustering (MIMIC) algorithm
 * was developed by De Bonet et. al. Each generation MIMIC selects promising
 * solutions and searches for the best permutation between the variables in
 * order to maximize the so-called mutual information of neighboring variables.
 * 
 * The Kullback-Leibler divergence between the chain and the complete joint
 * distribution is minimized. The greedy algorithm starts in a variable with the
 * lowest unconditional entropy. The chain is expanded by adding a new variable
 * that minimizes the conditional entropy of the new variable given the last
 * variable in the chain. Once the full chain is constructed for the selected
 * population of promising solutions, new solutions are generated by sampling
 * the distribution.
 * 
 * @author Karlo Knezevic, karlo.knezevic@fer.hr
 * 
 */
public class MIMIC extends Algorithm {

	private double indEstimationRatio;
	private final double reducingFactor;

	public MIMIC(Random rand, Genotype genotype, Selection selection,
			Evaluation evaluation, int maxGenerations, int stagnation,
			int elitism, double estimationProbab) {

		super(rand, genotype, selection, evaluation, maxGenerations,
				stagnation, elitism);

		name = "mimic";

		indEstimationRatio = estimationProbab;
		reducingFactor = computeReducingFactor(estimationProbab,
				0.1 * estimationProbab);

	}

	@Override
	public void run() {

		population = genotype.getIndividual().createPopulation(true);

		evaluation.evaluate(population);

		int generation = 0;
		while ((generation < maxGenerations) && !stagnate()) {
			++generation;

			runStep(population);

			indEstimationRatio *= reducingFactor;

			getBest(population);

			pushData(population, generation);

		}

	}

	@Override
	public Individual[] runStep(Individual[] population) {

		Arrays.sort(population);

		final Individual[] sampled = statistics.createPopulation(statistics
				.mutualInformationMaximizing(selection.selectBetterIndividuals(
						population, indEstimationRatio)));

		evaluation.evaluate(sampled);

		insertIntoPopulation(population, sampled, indEstimationRatio);

		return population;
	}

}